use std::{
    collections::HashMap,
    fs::File,
    io::{prelude::*, BufReader},
    sync::Arc,
};

use anyhow::Result;
use askama::Template;
use rayon::prelude::*;

use crate::{config::Config, handle, template::RatticeTemplate};

const WARTERMARK: &str = "<!-- Generated by Rattice -->";

pub fn generate_static_pages(config: Arc<Config>) -> Result<()> {
    let mut next_targets = vec!["/".to_owned()];
    let mut processed_targets = vec![];
    loop {
        let mut child_containers_vec = vec![];
        for target_uri in &next_targets {
            let containers = handle::walk_dir(target_uri, &HashMap::new(), &config)
                .map_err(|e| e.into_internal())?;
            child_containers_vec.push(containers.clone());

            let template = RatticeTemplate::new(
                target_uri,
                "",
                containers,
                config.lazy(),
                config.title_prefix(),
                true,
            );

            let path = format!("{}index.html", &target_uri[1..]);
            if let Ok(file) = File::open(&path) {
                let mut reader = BufReader::new(file);
                let mut line = String::new();
                match reader.read_line(&mut line) {
                    Ok(_) => {
                        if line.trim_end() != WARTERMARK {
                            println!("{} exists. Overwrite? (y/N)", path);
                            let mut input = String::new();
                            std::io::stdin().read_line(&mut input)?;
                            if input.trim() != "y" {
                                continue;
                            }
                        }
                    }
                    Err(e) => tracing::error!("Failed to read {}: {}", path, e),
                };
            }

            let mut file = match File::create(&path) {
                Ok(f) => f,
                Err(e) => {
                    tracing::error!("Failed to create {}: {}", path, e);
                    continue;
                }
            };

            match file.write_all(template.render()?.as_bytes()) {
                Ok(_) => tracing::info!("Generated {}", path),
                Err(e) => tracing::error!("Failed to write to {}: {}", path, e),
            };
        }

        next_targets.clear();
        for containers in &child_containers_vec {
            for container in containers {
                let mut urls: Vec<String> = container
                    .files()
                    .par_iter()
                    .filter(|f| {
                        f.is_dir() && f.name() != ".." && !processed_targets.contains(&f.to_uri())
                    })
                    .map(|f| f.to_uri())
                    .collect();
                processed_targets.append(&mut urls.clone());
                next_targets.append(&mut urls)
            }
        }

        if next_targets.is_empty() {
            break;
        }
    }

    Ok(())
}

pub fn remove_static_pages() -> Result<()> {
    for entry in glob::glob("**/index.html")? {
        let path = match entry {
            Ok(path) => path,
            Err(e) => {
                tracing::error!("Failed to glob path: {}", e);
                continue;
            }
        };

        if let Ok(file) = File::open(&path) {
            let mut reader = BufReader::new(file);
            let mut line = String::new();
            match reader.read_line(&mut line) {
                Ok(_) => {
                    if line.trim_end() == WARTERMARK {
                        if let Err(e) = std::fs::remove_file(&path) {
                            tracing::error!("Failed to remove {}: {}", path.display(), e);
                            continue;
                        }
                        tracing::info!("Removed {}", path.display());
                    }
                }
                Err(e) => tracing::error!("Failed to read {}: {}", path.display(), e),
            };
        }
    }
    Ok(())
}
